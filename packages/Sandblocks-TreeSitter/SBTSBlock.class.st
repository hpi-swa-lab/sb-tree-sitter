Class {
	#name : #SBTSBlock,
	#superclass : #SBBlock,
	#instVars : [
		'slot',
		'highlight',
		'range',
		'valid'
	],
	#category : #'Sandblocks-TreeSitter-UI'
}

{ #category : #'as yet unclassified' }
SBTSBlock class >> diffSourceExample [

	| oldRoot newRoot oldSource newSource |
	oldRoot := SBPython parse: 'def a():
	aa
3+5'.
	newRoot := SBPython parse: 'def a():
	aa
3+54'.
	oldSource := (oldRoot queryNode: '(_) ="5" @') parentSandblock.
	newSource := (newRoot queryNode: '(_) ="54" @') parentSandblock.
	^ oldSource undamagedParentWith: newSource do: [:old :new | | isoMorph |
		SBWatch report: old type for: 370389481.
		SBWatch report: new type for: 26606019.
		isoMorph := OrderedCollection new.
		old allBlocksBreadthFirstDo: [:oldBlock |
			new allBlocksBreadthFirstDo: [:newBlock |
				((isoMorph noneSatisfy: [:pair | (oldBlock hasParent: pair key) or: [newBlock hasParent: pair value]]) and: oldBlock sourceString = newBlock sourceString)
					ifTrue: [
						isoMorph add: oldBlock -> newBlock.
						true]
					ifFalse: [false]]].
		SBWatch report: isoMorph for: 182060115.
		new allBlocksDo: [:n | n attachDecorator: SBErrorDecorator new].
		SBToggledCode
			comment: ''
			active: 1
			do: {[isoMorph do: [:pair | pair value replaceBy: pair key]]}.
		old childSandblocks copy do: [:s | s delete].
		old addAllMorphs: new childSandblocks.
		SBWatch report: oldRoot for: 471971832]
]

{ #category : #'as yet unclassified' }
SBTSBlock class >> registerShortcuts: aProvider [

	aProvider
		registerShortcut: Character space asSandblockShortcut, $e command do: #promptTransition;
		registerShortcut: Character space shift do: #promptTransition;
		registerShortcut: $. command do: #codeAction
]

{ #category : #'as yet unclassified' }
SBTSBlock >> absorbsInput: anEvent [

	(anEvent commandKeyPressed or: [anEvent optionKeyPressed or: [anEvent controlKeyPressed]]) ifTrue: [^ false].
	
	(anEvent keyCharacter = Character tab and: [SBToggledCode comment: '' active: 1 do: {[true]. [anEvent shiftPressed]}]) ifTrue: [^ false].
	
	^ anEvent keyCharacter isPrintable and: [ | text oldContents oldPosition |
		text := self activeTextMorph.
		oldContents := text contentsForEdit.
		
		anEvent keyCharacter = Character cr ifTrue: [^ (oldContents lineCount <= 1 and: [anEvent commandKeyPressed not]) not].
		
		oldPosition := text cursor.
		[
			text keyStroke: anEvent.
			self prefixValidFor: text in: self submorphs] ensure: [
			text
				contents: oldContents;
				basicCursor: oldPosition]]
]

{ #category : #actions }
SBTSBlock >> actionProviders [

	^ {self language}, super actionProviders
]

{ #category : #converting }
SBTSBlock >> adaptSlot: aConverter [
	<convert>

	aConverter
		if: [
			(aConverter objectInterface first isKindOf: SBTSObjectInterface)
				ifTrue: [(self adaptSlotFor: aConverter objectInterface first slot ifFailed: [false]) ~~ false]
				ifFalse: [false]]
		do: [
			self copyBlock
				adaptSlotFor: aConverter objectInterface first slot
				ifFailed: [self assert: false]]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> adaptSlotFor: anotherSlot [

	^ self adaptSlotFor: anotherSlot ifFailed: [self error: 'blocks not compatible']
]

{ #category : #'inline block compat' }
SBTSBlock >> adaptSlotFor: anotherSlot ifFailed: aBlock [

	| results |
	" examples:
	* self=stmt,expr,id		anotherSlot=expr|num
	* self=stmt,expr,id		anotherSlot=stmt,expr,id
	* self=expr,id 			anotherSlot=stmt
	"
	results := SBTSInputParser new
		allowIncomplete: false;
		optionsForTemplate: anotherSlot transitionRoot givenBlocks: {self}.
	results ifEmpty: [^ aBlock value].
	self assert: results size = 1.
	self assert: results first size = 1.
	^ results first first
]

{ #category : #accessing }
SBTSBlock >> addBlock: aBlock [
	"use this when adding foreign blocks to self, it will adapt the slot accordingly, if possible"

	self
		cursorPositionsDo: [:pos |
			pos isInsert ifTrue: [ | targetSlot |
				targetSlot := SBTSSlot new addNode: pos command element.
				(aBlock adaptSlotFor: targetSlot ifFailed: [nil]) ifNotNil: [:newBlock | ^ self addMorphBack: newBlock]]]
		shallow: true.
	self error: ('no suitable insertion point for a `{1}` in a `{2}` found' format: {aBlock printString. self printString})
]

{ #category : #'inline block compat' }
SBTSBlock >> alias [

	^ self slot alias
]

{ #category : #replacements }
SBTSBlock >> allReplacementCandidates: aCollection [

	^ Array streamContents: [:s |
		aCollection do: [:class |
			Pragma
				withPragmasIn: class
				do: [:pragma | (#(#lang:match: #lang:match:sample: #lang:match:sample:keyword:) includes: pragma keyword) ifTrue: [s nextPut: pragma]]]]
]

{ #category : #replacements }
SBTSBlock >> applyReplacement [

	^ self applyReplacement: nil
]

{ #category : #replacements }
SBTSBlock >> applyReplacement: aClass [

	(self isTSReplacement and: [self class = aClass]) ifTrue: [^ self].
	
	^ (self applyReplacementCommand: aClass) do
]

{ #category : #replacements }
SBTSBlock >> applyReplacementCommand [

	^ self applyReplacementCommand: nil
]

{ #category : #replacements }
SBTSBlock >> applyReplacementCommand: aClass [

	| candidates |
	candidates := self allReplacementCandidates: (aClass ifNil: [SBTSReplacementBlock allSubclasses] ifNotNil: [{aClass}]).
	candidates do: [:pragma | | blockClass |
		blockClass := pragma methodClass.
		
		SBToggledCode
			comment: ''
			active: 0
			do: {[pragma selector = #buildTypescriptWeb ifTrue: [self halt]]}.
		
		(blockClass
			match: self
			against: (SBTSQuery new prepare: pragma arguments second)
			buildSelector: pragma selector) ifNotNil: [:cmd | ^ cmd]].
	^ nil
]

{ #category : #actions }
SBTSBlock >> applyReplacements [
	<action>

	| candidates |
	candidates := self allReplacementCandidates: SBTSReplacementBlock allSubclasses.
	self allBlocksDo: [:block |
		(block isTSBlock and: [block isTSReplacement not]) ifTrue: [
			self
				tryApplyReplacements: (candidates select: [:pragma | pragma arguments first = block language language])
				to: block]]
]

{ #category : #actions }
SBTSBlock >> asForeignLanguage [
	<action>

	| option options |
	options := SBTSLanguage allSubclasses.
	option := UIManager default chooseFrom: options.
	option = 0 ifTrue: [^ self].
	self replaceBlock: (SBForeignLanguage new
		slot: self slot copy;
		string: self contents language: (options at: option) for: self)
]

{ #category : #converting }
SBTSBlock >> asSlider: converter [
	<convert>

	converter
		if: [(self language respondsTo: #sourceForSlider:) and: [self type = #float or: [self type = #integer or: [self type = #number or: [self type = #'num_lit']]]]]
		do: [self language sourceForSlider: self]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> blockAtLine: aNumber column: anotherNumber [

	| pos |
	pos := SBTSPosition line: aNumber character: anotherNumber.
	^ self smallestBlockEncompassig: (SBTSRange start: pos end: pos)
]

{ #category : #accessing }
SBTSBlock >> children [

	^ self submorphs
]

{ #category : #'inline block compat' }
SBTSBlock >> childrenForQuery [
	"remove, compat with inlineblocks"

	self flag: #todo.
	^ self children
]

{ #category : #'as yet unclassified' }
SBTSBlock >> childrenToKeepDuringDelete [

	| current keep found |
	"up until our current cursor position we use the more strict keepDuringTransform, everything after our cursor position we use the looser keepDuringDelete"
	current := self sandblockEditor cursor cursorPosition.
	keep := OrderedCollection new.
	found := false.
	self cursorPositionsDo: [:c |
		(c morph isTSMorph and: [c morph parentSandblock = self and: [(keep includes: c morph) not and: [(found ifTrue: [c morph keepDuringDelete] ifFalse: [c morph keepDuringTransform]) or: [c morph slot isStatementIn: c morph owner]]]]) ifTrue: [keep add: c morph].
		c = current ifTrue: [found := true]].
	
	((current isText or: [current isSelect]) and: [current morph keepDuringDelete not]) ifTrue: [keep remove: current morph ifAbsent: []].
	
	^ keep
]

{ #category : #'*Sandblocks-TreeSitter-LanguageClient' }
SBTSBlock >> chooseFrom: aCollection [

	^ aCollection size
		caseOf: {
			[0] -> [0].
			[1] -> [1]}
		otherwise: [UIManager default chooseFrom: aCollection]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> clearCacheSelf [

	valid := nil.
	super clearCacheSelf
]

{ #category : #'*Sandblocks-TreeSitter-LanguageClient' }
SBTSBlock >> codeAction [
	<action>

	self semantics
		codeActionsFor: self
		choosing: [:codeActions | self chooseFrom: codeActions]
		blocking: true
]

{ #category : #actions }
SBTSBlock >> collapseBlock [
	<action>

	| collapsed command |
	collapsed := SBTSCollapsed new.
	command := SBWrapCommand new
		outer: collapsed;
		inner: self;
		wrap: [:collapse :block | collapse block: block];
		selectAfter: collapsed.
	self sandblockEditor ifNotNil: [:e | e do: command] ifNil: [command do].
	^ collapsed
]

{ #category : #'as yet unclassified' }
SBTSBlock >> colorPolicy [

	| policy |
	policy := super colorPolicy.
	^ policy copy enlarge: (self language alwaysEnlargeInsets or: [policy enlarge])
]

{ #category : #'as yet unclassified' }
SBTSBlock >> compatibleWithType: aString [

	^ self slot compatibleWithType: aString
]

{ #category : #testing }
SBTSBlock >> computeIsBlockBody [

	self slot firstNode bodyTemplate allChildrenDo: [:node | (node isTSRepeat and: [node isStatementRepeater]) ifTrue: [^ true]].
	^ false
]

{ #category : #'as yet unclassified' }
SBTSBlock >> contentsForEdit [

	^ self contents
]

{ #category : #accessing }
SBTSBlock >> contentsToDisplay [

	^ self contents
]

{ #category : #'as yet unclassified' }
SBTSBlock >> copyBlock [

	| copy |
	copy := self class new
		addAllMorphs: (self isUnknown ifTrue: [{}] ifFalse: [self submorphs collect: [:s | s copyBlock]]);
		range: range copy;
		slot: self slot.
	#(#lastConstructed #copyPlaceholder) do: [:prop | self valueOfProperty: prop ifPresentDo: [:val | copy setProperty: prop toValue: val]].
	^ copy
]

{ #category : #'as yet unclassified' }
SBTSBlock >> copyOnDrag [

	^ self language copyOnDrag: self
]

{ #category : #'as yet unclassified' }
SBTSBlock >> currentTextMorph [

	self submorphsDo: [:m | (m isTSMorph and: [m isTextMorph and: [m symmetricSibling isNil]]) ifTrue: [^ m]].
	self submorphsDo: [:m | m isTextMorph ifTrue: [^ m]].
	^ nil
]

{ #category : #'as yet unclassified' }
SBTSBlock >> cursorPositionsDo: aBlock shallow: aBoolean [

	aBlock value: (SBCursorSelect new block: self).
	self template
		cursorPositionsDo: aBlock
		shallow: aBoolean
		blocks: self children readStream
		parent: self
]

{ #category : #'as yet unclassified' }
SBTSBlock >> deleteBeforeCursor [
	<action>

	| editor textMorph target |
	editor := self sandblockEditor.
	
	textMorph := editor currentInputCommand ifNotNil: #textMorph.
	(textMorph ifNotNil: #contentsForEdit ifNil: ['']) ifNotEmpty: [
		super deleteBeforeCursor.
		(self valid not and: [textMorph contents notEmpty]) ifTrue: [ | currentCursor evalOption textMorphIndex |
			currentCursor := textMorph cursor.
			textMorphIndex := editor selection textMorphs indexOf: textMorph.
			evalOption := [:options |
				editor do: options first.
				editor currentInputCommand
					ifNotNil: [:c |
						c block textMorphs
							at: textMorphIndex
							ifPresent: [:other |
								other ~= c textMorph
									ifTrue: [editor startInput: editor selection at: currentCursor replacingContents: false in: other]
									ifFalse: [c textMorph moveCursorTo: currentCursor]]
							ifAbsent: [c textMorph moveCursorTo: currentCursor]]
					ifNil: [editor selection lastDeepChild startInputAtEnd]].
			(SBTSInputReconcile new
				tryReinterpretFrom: textMorph
				in: self
				given: ''
				at: SBTSInputReconcile endIndex
				fullToken: true)
				ifNotEmpty: evalOption
				ifEmpty: [
					(SBTSInputReconcile new
						tryReinterpretFrom: textMorph
						in: self owner
						given: ''
						at: SBTSInputReconcile endIndex
						fullToken: true) ifNotEmpty: evalOption]].
		^ self].
	
	target := self.
	3 timesRepeat: [
		target reinterpretWithoutEmpty ifTrue: [^ self].
		target := target parentSandblock.
		target isTSBlock ifFalse: [^ editor performForSelection: #moveCursorLeft]].
	^ editor performForSelection: #moveCursorLeft
]

{ #category : #'as yet unclassified' }
SBTSBlock >> deleteBeforeCursorOld [
	<action>

	| editor textMorph target |
	editor := self sandblockEditor.
	
	editor mode = #insert ifTrue: [ | newPos |
		newPos := editor cursor cursorPosition moveHorizontal: -1 wordWise: false.
		newPos ifNil: [^ self].
		
		^ (newPos block = self or: [newPos block hasOwner: self])
			ifTrue: [self sandblockEditor performForSelection: #moveCursorLeft]
			ifFalse: [
				(self parentSandblock deleteCommandFor: self) ifNotNil: [:c | | pos |
					pos := editor cursor positionBefore: c commands first target.
					editor do: c.
					editor cursor cursorPosition: pos explicitMove: true axis: #x.
					^ self]]].
	
	textMorph := self sandblockEditor currentInputCommand textMorph.
	self contents ifNotEmpty: [
		super deleteBeforeCursor.
		(self valid not and: [self contents notEmpty]) ifTrue: [
			(SBTSInputReconcile new
				tryReinterpretFrom: self currentTextMorph
				in: self owner
				given: ''
				at: SBTSInputReconcile endIndex) ifNotEmpty: [:options | editor do: options first]].
		^ self].
	
	textMorph submorphBefore ifNil: [
		(self parentSandblock deleteCommandFor: self) ifNotNil: [:c | | pos |
			pos := editor cursor positionBefore: c commands first target.
			editor do: c.
			editor cursor cursorPosition: pos explicitMove: true axis: #x.
			^ self]].
	
	target := self.
	3 timesRepeat: [
		target reinterpretWithoutEmpty ifTrue: [^ self].
		target := target parentSandblock.
		target isTSBlock ifFalse: [
			self childSandblocks size > 0
				ifTrue: [self changeToUnknown]
				ifFalse: [editor performForSelection: #moveCursorLeft].
			^ self]].
	self childSandblocks size > 0
		ifTrue: [self changeToUnknown]
		ifFalse: [editor performForSelection: #moveCursorLeft]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> deleteCommandFor: aBlock [

	aBlock isTSMorph ifFalse: [^ super deleteCommandFor: aBlock].
	
	(self deleteCommandForNoReplace: aBlock) ifNotNil: [:cmd | ^ cmd].
	
	^ aBlock newNullBlock convertedFor: aBlock objectInterface do: [:new |
		new ifNotNil: [
			SBReplaceCommand new
				target: aBlock;
				replacer: new;
				shouldMergeWithNext: true;
				yourself]]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> deleteCommandForNoReplace: aBlock [

	| target |
	target := aBlock.
	" walk up the chain of nodes, looking for either a repeater that we can delete from or any nodes that would have created other blocks, thus changing our deletion target "
	aBlock slot allParentsDo: [:p |
		(p createsNewBlock and: [p ~= aBlock slot firstNode]) ifTrue: [target := target parentSandblock].
		p isTSRepeat ifTrue: [ | groups |
			groups := p groupsIn: target owner.
			(p required not or: [groups size > 1]) ifTrue: [groups do: [:group | (group includes: target) ifTrue: [^ SBCombinedCommand newWith: (group collect: [:block | SBDeleteCommand new target: block])]]]]].
	
	^ nil
]

{ #category : #'as yet unclassified' }
SBTSBlock >> deselectedTextMorph: aMorph for: aNewPosition cursor: aCursor [

	super deselectedTextMorph: aMorph for: aNewPosition cursor: aCursor.
	(aNewPosition isText and: [aNewPosition block isKindOf: SBTSInputReconcile]) ifTrue: [^ self].
	
	aCursor previousMoveWasExplicit ifTrue: [
		self owner ifNotNil: [
			self owner submorphs
				from: 1
				to: self submorphIndex
				do: [:m | (m isTSMorph and: [m isTextMorph]) ifTrue: [m confirmFixedText]]].
		aMorph owner submorphs
			from: 1
			to: aMorph submorphIndex
			do: [:m | (m isTSMorph and: [m isTextMorph]) ifTrue: [m confirmFixedText]]]
]

{ #category : #events }
SBTSBlock >> doubleClick: evt [

	super doubleClick: evt.
	
	SBToggledCode comment: '' active: 1 do: {[self collapseBlock]. [self gotoDefinition]}
]

{ #category : #drawing }
SBTSBlock >> drawBackgroundOn: aCanvas [

	| policy |
	policy := self colorPolicy.
	^ aCanvas
		frameAndFillRoundRect: self bounds
		radius: policy cornerRadius
		fillStyle: Color transparent
		borderWidth: (policy borderWidthForBlock: self)
		borderColor: (policy borderColorForBlock: self)
]

{ #category : #'as yet unclassified' }
SBTSBlock >> drawnColor [

	^ self prefersNoBorder
		ifTrue: [super drawnColor alpha: 0]
		ifFalse: [super drawnColor]
]

{ #category : #accessing }
SBTSBlock >> effectiveContents [

	^ self contents
]

{ #category : #'as yet unclassified' }
SBTSBlock >> emphasis [

	self highlight ifNotNil: [:h |
		(h beginsWith: 'major_declaration') ifTrue: [^ TextEmphasis bold].
		self type = #comment ifTrue: [^ TextEmphasis italic]].
	^ self colorPolicy defaultEmphasis
]

{ #category : #testing }
SBTSBlock >> encompasses: aRange [

	^ self range encompasses: aRange
]

{ #category : #'as yet unclassified' }
SBTSBlock >> evaluate [

	self containingArtefact ifNotNil: [:a | (a respondsTo: #evaluate:) ifTrue: [^ a evaluate: self]].
	^ self language runtime evaluate: self sourceString
]

{ #category : #actions }
SBTSBlock >> evaluateExpression [
	<action>
	<actionValidIf: #isExpression>

	| result |
	result := self evaluate.
	^ result explore
]

{ #category : #accessing }
SBTSBlock >> factory [

	^ self slot factory
]

{ #category : #'as yet unclassified' }
SBTSBlock >> field [

	^ self slot field
]

{ #category : #'as yet unclassified' }
SBTSBlock >> firstSourceCharacter [

	self writeSourceOn: (SBImmediateStream with: [:c | ^ c]) indent: 0 forCompare: false.
	^ nil
]

{ #category : #'as yet unclassified' }
SBTSBlock >> fixedNumberOfChildren [

	self cursorPositionsDo: [:c | (c isKindOf: SBCursorInsert) ifTrue: [^ false]] shallow: true.
	^ true
]

{ #category : #'as yet unclassified' }
SBTSBlock >> get: aFieldNameString [

	| matches |
	matches := self children select: [:child | child field = aFieldNameString].
	matches ifNotEmpty: [
		^ (matches size > 1 and: [matches first slot includesRepeat])
			ifTrue: [matches]
			ifFalse: [matches first]].
	^ nil
]

{ #category : #'as yet unclassified' }
SBTSBlock >> getSourceStringAndMark [

	| stream |
	stream := SBLineInfoStream on: ''.
	self writeSourceOn: stream indent: 0 forCompare: false.
	^ stream contents
]

{ #category : #'*Sandblocks-TreeSitter-LanguageClient' }
SBTSBlock >> gotoDefinition [
	<action>

	self semantics
		definitionsOf: self
		choosing: [:definitions | self chooseFrom: definitions]
		do: [:definition | definition select]
		blocking: true
]

{ #category : #'as yet unclassified' }
SBTSBlock >> grammarHandler [

	^ SBTSGrammarHandler new
]

{ #category : #'as yet unclassified' }
SBTSBlock >> handleMouseEnter: anEvent [

	| hover |
	super handleMouseEnter: anEvent.
	self parentSandblock removeAlarm: #showHover.
	hover := self valueOfProperty: #hover ifAbsent: [^ self addAlarm: #showHover after: 800].
	hover cancelDelete
]

{ #category : #'as yet unclassified' }
SBTSBlock >> handleMouseLeave: anEvent [

	super handleMouseLeave: anEvent.
	self valueOfProperty: #hover ifPresentDo: [:hover | hover deleteSoon].
	self removeAlarm: #showHover
]

{ #category : #highlight }
SBTSBlock >> highlight [

	^ highlight ifNil: [self updateAllHighlights]
]

{ #category : #highlight }
SBTSBlock >> highlight: aString [

	highlight := aString
]

{ #category : #'as yet unclassified' }
SBTSBlock >> indentFor: aBlock current: aNumber [

	^ (self language indentMatch: aBlock)
		ifTrue: [aNumber + 1]
		ifFalse: [aNumber]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> initialize [

	super initialize.
	
	range := SBTSRange
		start: (SBTSPosition line: 0 character: 0)
		end: (SBTSPosition line: 0 character: 0).
	
	self
		layoutPolicy: SBAlgebraLayout new;
		layoutInset: 0;
		cellGap: 2 sbScaled;
		hResizing: #shrinkWrap;
		vResizing: #shrinkWrap
]

{ #category : #'as yet unclassified' }
SBTSBlock >> insertCommandRequest: aMorph near: aBlock before: aBoolean [

	aBlock ifNil: [^ nil].
	
	aBlock slot lastRepeater ifNotNil: [:repeater | ^ SBRelInsertCommand new near: aBlock before: aBoolean in: self morph: aMorph].
	
	^ nil
]

{ #category : #actions }
SBTSBlock >> insertStatementAbove [
	<action>

	self insertStatementAboveOrBelow: true
]

{ #category : #actions }
SBTSBlock >> insertStatementAboveOrBelow: anAboveBoolean [

	| eval |
	eval := [:pos | pos isInsert and: [pos command isStatementInsert]].
	(anAboveBoolean
		ifFalse: [self cursorPositionInSelfOrAfterThat: eval]
		ifTrue: [self cursorPositionsInSelfOrBeforeThat: eval]) ifNotNil: [:pos |
		pos command element isTSChoice ifTrue: [
			pos command element alternatives
				detect: [:alt | alt type = #empty]
				ifFound: [:alt | pos command morphs: alt buildEmpty]].
		self sandblockEditor do: pos command]
]

{ #category : #actions }
SBTSBlock >> insertStatementBelow [
	<action>
	<actionValidIf: #insertStatementHasCandidate>

	self insertStatementAboveOrBelow: false
]

{ #category : #'as yet unclassified' }
SBTSBlock >> insertStatementHasCandidate [

	self andAllParentSandblocksDo: [:block |
		block isTSBlock ifTrue: [
			"look in my template --> insert as child of me"
			(block slot repeaterThat: [:p | p isStatementRepeater]) ifNotNil: [:repeater | ^ true].
			"look above me --> insert adjacent to me"
			block
				cursorPositionsDo: [:cursor | (cursor isInsert and: [cursor command element parent isStatementRepeater]) ifTrue: [^ true]]
				shallow: true]].
	^ false
]

{ #category : #testing }
SBTSBlock >> isBlockBody [

	^ self valueOfProperty: #isBlockBody ifAbsentPut: [self computeIsBlockBody]
]

{ #category : #testing }
SBTSBlock >> isEditor [

	^ true
]

{ #category : #testing }
SBTSBlock >> isExpression [

	self slot allSuperTypesDo: [:type | (self language isExpression: type) ifTrue: [^ true]].
	^ false
]

{ #category : #testing }
SBTSBlock >> isMyActiveKeyword: aString [

	^ self activeTextMorph
		ifNotNil: [:t | t slot firstNode isTSLabel and: [t slot firstNode label = aString]]
		ifNil: [false]
]

{ #category : #testing }
SBTSBlock >> isOneStatementPerArtefact [

	^ self language isOneStatementPerArtefactFor: self
]

{ #category : #'as yet unclassified' }
SBTSBlock >> isPart [

	^ self highlight notNil and: [self highlight endsWith: '.part']
]

{ #category : #'file range' }
SBTSBlock >> isSingleLine [

	^ self range isSingleLine
]

{ #category : #testing }
SBTSBlock >> isTSBlock [

	^ true
]

{ #category : #testing }
SBTSBlock >> isTSMorph [

	^ true
]

{ #category : #'as yet unclassified' }
SBTSBlock >> isTSReplacement [

	^ false
]

{ #category : #'as yet unclassified' }
SBTSBlock >> isTopLevel [

	^ self type = self language rootRuleName
]

{ #category : #testing }
SBTSBlock >> keepDuringDelete [

	^ self submorphs anySatisfy: [:s | s isTSMorph not or: [s keepDuringDelete]]
]

{ #category : #testing }
SBTSBlock >> keepDuringTransform [

	^ self submorphs anySatisfy: [:s | s isTSMorph not or: [s keepDuringTransform]]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> keyStroke: anEvent [

	self tryApplyChange: [:textMorph | super keyStroke: anEvent] input: anEvent keyCharacter asString
]

{ #category : #accessing }
SBTSBlock >> language [

	^ self factory language
]

{ #category : #accessing }
SBTSBlock >> lastConstructedChild [

	self allMorphsDo: [:m | m valueOfProperty: #lastConstructed ifPresentDo: [:prop | ^ m]].
	^ nil
]

{ #category : #'as yet unclassified' }
SBTSBlock >> layoutCommands [

	self hasSubmorphs ifFalse: [^ SBAlgebraCommand morph data: self].
	
	^ SBAlgebraCommand container
		morph: self;
		data: (Array streamContents: [:stream |
			self children overlappingPairsDo: [:a :b |
				stream nextPut: a layoutCommands.
				(self factory addIndent: a) ifTrue: [stream nextPut: SBAlgebraCommand addIndent].
				(self factory removeIndent: b) ifTrue: [stream nextPut: SBAlgebraCommand removeIndent].
				(self factory hardLineBreakBetween: a and: b)
					ifTrue: [stream nextPut: (SBAlgebraCommand hardLine withGap: true)]
					ifFalse: [
						(self factory softLineBreakBetween: a and: b)
							ifTrue: [
								stream nextPut: (((self factory gapBetween: a and: b)
									ifTrue: [SBAlgebraCommand softLineOrGap]
									ifFalse: [SBAlgebraCommand softLine]) withGap: true)]
							ifFalse: [(self factory gapBetween: a and: b) ifTrue: [stream nextPut: SBAlgebraCommand gap]]]].
			self submorphs ifNotEmpty: [stream nextPut: self lastSubmorph layoutCommands]])
]

{ #category : #hierarchy }
SBTSBlock >> linearizeOn: aStream [

	SBToggledCode
		comment: ''
		active: 0
		do: {[(self submorphCount = 1 and: [self firstSubmorph isTextMorph]) ifTrue: [^ aStream nextPut: self]]}.
	self submorphs overlappingPairsDo: [:a :b |
		a linearizeOn: aStream.
		aStream nextPutAll: (self slot separatorBetween: a and: b indent: 0 lastCharacterOfFirst: (aStream position > 0
			ifFalse: [$ ]
			ifTrue: [aStream last isMorph ifTrue: [aStream last contents last] ifFalse: [aStream last]]))].
	self hasSubmorphs ifTrue: [self lastSubmorph linearizeOn: aStream]
]

{ #category : #query }
SBTSBlock >> matchesQuery: aString [

	^ SBTSQuery new execute: aString against: self capturesDo: [:b | ]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> minExtent [

	^ super minExtent max: 0 @ TextStyle defaultFont height
]

{ #category : #'as yet unclassified' }
SBTSBlock >> newEmptyChildNear: aBlock before: aBoolean [

	aBlock ifNil: [^ nil].
	aBlock isTSMorph ifFalse: [^ nil].
	aBlock slot lastRepeater ifNotNil: [:repeater |
		self flag: #todo.
		"can return multiple"
		^ repeater element buildEmpty first].
	^ nil
]

{ #category : #'as yet unclassified' }
SBTSBlock >> newNullBlock [

	^ SBTSUnknownBlock new slot: (SBTSSlot with: self slot lastNode)
]

{ #category : #'as yet unclassified' }
SBTSBlock >> objectInterface [

	^ self parentSandblock
		ifNotNil: [:p | p objectInterfaceForChild: self]
		ifNil: [SBInterfaces block]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> objectInterfaceForChild: aBlock [

	^ aBlock isTSBlock
		ifTrue: [
			{
				SBTSObjectInterface new
					slot: aBlock slot;
					at: (SBCursorSelect new block: aBlock)}]
		ifFalse: [SBInterfaces never]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> objectInterfaceForInsert: aCommand [

	(aCommand isKindOf: SBTSNodeInsertCommand) ifFalse: [^ SBInterfaces never].
	
	^ {
		SBTSObjectInterface new
			slot: (SBTSSlot with: aCommand element);
			at: (SBCursorInsert new
				command: aCommand;
				before: false;
				adjacent: nil;
				container: aCommand container)}
]

{ #category : #highlight }
SBTSBlock >> ownerWithForegroundColor [

	^ self highlight = #'_sb_none'
		ifTrue: [self owner ifNotNil: [:o | o ownerWithForegroundColor]]
		ifFalse: [self]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> pickUp: anEvent [

	self isPart ifTrue: [self owner pickUp: anEvent] ifFalse: [super pickUp: anEvent]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> placeCursorCloseAfterDo: aBlock [

	| index container found |
	container := self owner.
	index := 0.
	found := false.
	container cursorPositionsDo: [:c |
		(found not and: [
			SBToggledCode
				comment: ''
				active: 1
				do: {[self sandblockEditor selection activeTextMorph ~= c morph]. [c block ~= self or: [c isSelect]]}])
			ifTrue: [c isSelect ifFalse: [index := index + 1]]
			ifFalse: [found := true]].
	
	"if we are in a repeater for multiple elements and we delete ourselves, then cursor positions actually disappear"
	
	aBlock value.
	
	SBToggledCode comment: '' active: 0 do: {
		[ | count |container sandblockEditor selection recursiveSubmorphCount < count ifTrue: [index := index - 1]].
		[(self slot repeaterThat: #multiple) ifNotNil: [index := index - 1]]}.
	
	found ifTrue: [
		container cursorPositionsDo: [:c |
			c isSelect ifFalse: [
				index > 1 ifTrue: [index := index - 1] ifFalse: [
					"if we were to be put inside our container and not in the child, don't move"
					nil.
					(SBToggledCode comment: '' active: 1 do: {[true]. [c block ~= container]}) ifTrue: [
						^ container sandblockEditor cursor
							cursorPosition: (c placeAtEnd: true)
							explicitMove: true
							axis: #none]]]]].
	container sandblockEditor selection lastDeepChild startInputAtEnd
]

{ #category : #'as yet unclassified' }
SBTSBlock >> preferInsertCursor [

	^ self type = self language rootRuleName
]

{ #category : #highlight }
SBTSBlock >> preferredColorIn: aColorPolicy [

	^ self slot preferredColorIn: aColorPolicy for: self highlight
]

{ #category : #'as yet unclassified' }
SBTSBlock >> prefersNoBorder [

	^ self isPart
]

{ #category : #testing }
SBTSBlock >> prefixValidFor: aTextMorph in: aSiblingsCollection [

	^ aTextMorph isTSMorph not or: [
		aTextMorph slot firstNode
			prefixValidFor: aTextMorph effectiveContents
			in: aSiblingsCollection]
]

{ #category : #accessing }
SBTSBlock >> prettySourceString [

	self allBlocksDo: [:b | b valid ifFalse: [^ self sourceString]].
	^ self language runtime
		ifNotNil: [:r | r prettyPrint: self sourceString]
		ifNil: [self sourceString]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> printLabelOn: aStream [

	self printOn: aStream
]

{ #category : #'as yet unclassified' }
SBTSBlock >> printOn: aStream [

	self slot ifNotNil: [slot firstNode labelPrintOn: aStream]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> printTree [

	^ String streamContents: [:stream | self printTreeOn: stream indent: 0]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> printTreeOn: aStream indent: aNumber [

	| any |
	aStream nextPut: $(.
	self field ifNotNil: [
		aStream nextPutAll: self field.
		aStream nextPutAll: ': '].
	self printOn: aStream.
	any := false.
	self submorphsDo: [:m |
		m isTSBlock ifTrue: [
			any := true.
			aStream crtab: aNumber + 1.
			m printTreeOn: aStream indent: aNumber + 1]].
	any ifTrue: [aStream crtab: aNumber].
	aStream nextPut: $)
]

{ #category : #actions }
SBTSBlock >> promptTransition [
	<action>

	"(self language preferNoPopup and: [self language language = #smalltalk and: [ActiveEvent shiftPressed not]]) ifTrue: [ | message target |
		target := (self orOwnerSuchThat: [:b | b isTSBlock and: [b slot compatibleWithType: #expression]]) ifNil: [^ self].
		message := (self language blockFor: #'unary_message') adaptSlotFor: target slot.
		message childSandblocks first replaceBlock: target.
		^ self sandblockEditor do: (SBReplaceCommand new
			target: target replacer: message;
			selectAfter: message childSandblocks last)]."
	
	SBTSInputReconcile new
		explicitAppend: self isUnknown not;
		for: (self activeTextMorph ifNil: [self]) input: '' at: ((ActiveEvent shiftPressed or: [ActiveEvent isKeyboard and: [ActiveEvent keyCharacter = $e]])
			ifTrue: [1]
			ifFalse: [SBTSInputReconcile endIndex])
]

{ #category : #query }
SBTSBlock >> query: aString capturesDo: aBlock [

	^ SBTSQuery new execute: aString against: self capturesDo: aBlock
]

{ #category : #query }
SBTSBlock >> queryAll: aString [

	^ Array streamContents: [:stream |
		self allMorphsDo: [:block |
			block isTSMorph ifTrue: [ | captures |
				captures := nil.
				(SBTSQuery new execute: aString against: block capturesDo: [:cap | captures := cap]) ifTrue: [stream nextPut: captures anyOne]]]]
]

{ #category : #query }
SBTSBlock >> queryNode: aString [

	^ self queryNode: aString ifFound: [:e | e] ifNone: [self error: 'query did not match']
]

{ #category : #query }
SBTSBlock >> queryNode: aString ifFound: aSuccessBlock ifNone: aBlock [

	| element |
	(self
		queryRecursiveFirstMatch: aString
		capturesDo: [:captures :block | element := captures ifEmpty: [block] ifNotEmpty: [captures anyOne]]) ifFalse: [^ aBlock value].
	^ aSuccessBlock value: element
]

{ #category : #query }
SBTSBlock >> queryRecursiveFirstMatch: aString capturesDo: aBlock [

	self allMorphsDo: [:block |
		block isTSMorph ifTrue: [ | captures |
			captures := nil.
			(SBTSQuery new execute: aString against: block capturesDo: [:cap | captures := cap]) ifTrue: [
				aBlock cull: captures cull: block.
				^ true]]].
	^ false
]

{ #category : #'file range' }
SBTSBlock >> range [

	^ range
]

{ #category : #'file range' }
SBTSBlock >> range: aTSRange [

	range := aTSRange
]

{ #category : #converting }
SBTSBlock >> reinterpretString: aConverter [
	<convert>

	aConverter
		if: [
			((aConverter objectInterface first isKindOf: SBTSObjectInterface) and: [self submorphCount = 1 and: [self currentTextMorph notNil]])
				ifTrue: [
					(SBTSInputParser new
						allowIncomplete: false;
						rawOptionsForTemplate: aConverter objectInterface first slot transitionRoot
							given: self contents
							before: #()
							after: #()) notEmpty]
				ifFalse: [false]]
		do: [ | parser |
			parser := SBTSInputParser new.
			(parser
				allowIncomplete: false;
				rawOptionsForTemplate: aConverter objectInterface first slot transitionRoot
					given: self contents
					before: #()
					after: #()) anyOne blocks anyOne buildWith: parser]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> reinterpretWithoutEmpty [

	| remaining options editor |
	editor := self sandblockEditor.
	remaining := self childrenToKeepDuringDelete.
	remaining ifEmpty: [
		(self parentSandblock deleteCommandForNoReplace: self) ifNotNil: [:c |
			self placeCursorCloseAfterDo: [editor do: c].
			^ true].
		^ false].
	(remaining hasEqualElements: self submorphs) ifTrue: [^ false].
	
	options := SBTSInputParser new optionsFor: self given: '' before: remaining after: #().
	(options size = 1 and: [options first first sourceStringForCompare ~= self copyBlock sourceStringForCompare]) ifTrue: [
		self placeCursorCloseAfterDo: [editor do: (SBReplaceMultipleCommand new target: self replacers: options first)].
		^ true].
	SBToggledCode comment: '' active: 0 do: {
		[
			(remaining allSatisfy: [:m | m slot firstNode isTSLabel]) ifTrue: [
				(self parentSandblock deleteCommandFor: self) ifNotNil: [:c |
					editor do: c.
					editor selection moveCursorToEnd.
					^ true]]]}.
	^ false
]

{ #category : #'as yet unclassified' }
SBTSBlock >> repeaterGroup [

	self slot repeater ifNotNil: [:repeater | | myIndex mySubIndex seq start |
		myIndex := self submorphIndex.
		self flag: #todo.
		" does not consider nested repeats and nested seqs "
		seq := self slot parentThat: [:p | p isTSSeq and: [p hasParent: repeater]].
		seq ifNil: [^ {self}].
		
		mySubIndex := (self slot parentThat: [:p | p parent = seq]) in: [:c | c parent elements indexOf: c].
		start := myIndex - mySubIndex + 1.
		^ self owner children copyFrom: start to: start + seq elements size - 1].
	^ nil
]

{ #category : #accessing }
SBTSBlock >> replaceBlock: aBlock [

	| new |
	new := aBlock
		adaptSlotFor: self slot
		ifFailed: [self error: ('block not compatible (replace {1} with {2})' format: {self. aBlock})].
	self replaceBy: new.
	^ new
]

{ #category : #accessing }
SBTSBlock >> replaceBlockCommandWith: aBlock [

	| new |
	new := aBlock
		adaptSlotFor: self slot
		ifFailed: [self error: ('block not compatible (replace {1} with {2})' format: {self. aBlock})].
	^ SBReplaceCommand new target: self replacer: new
]

{ #category : #'as yet unclassified' }
SBTSBlock >> runtime [

	^ (self containingArtefact ifNotNil: [:a | a runtime]) ifNil: [self language runtime]
]

{ #category : #actions }
SBTSBlock >> selectStartOfStatement [
	<multiSelectAction>
	<inputAction>

	(self containingStatement ifNil: [self containingArtefact]) firstDeepChild select
]

{ #category : #accessing }
SBTSBlock >> semantics [

	self sandblockEditor runtimesDo: [:r | (r responsibleFor: self) ifTrue: [^ r semantics]].
	^ SBTSLanguageSemantics new
]

{ #category : #'as yet unclassified' }
SBTSBlock >> showHover [
	<action>

	self isInWorld ifFalse: [^ self].
	
	self semantics
		hoverFor: self
		do: [:contents |
			(contents notNil and: [contents notEmpty]) ifTrue: [
				self setProperty: #hover toValue: (SBTSHoverMorph new
					morph: self;
					contents: contents;
					openInWorld;
					reposition;
					yourself)]]
		blocking: true
]

{ #category : #'as yet unclassified' }
SBTSBlock >> slot [

	^ slot
]

{ #category : #'as yet unclassified' }
SBTSBlock >> slot: aSlot [

	self assert: (aSlot isKindOf: SBTSSlot).
	slot := aSlot
]

{ #category : #'as yet unclassified' }
SBTSBlock >> smallestBlockEncompassig: aRange [

	| min |
	min := self.
	self allBlocksDo: [:block | (block encompasses: aRange) ifTrue: [min recursiveSubmorphCount > block recursiveSubmorphCount ifTrue: [min := block]]].
	^ min
]

{ #category : #'as yet unclassified' }
SBTSBlock >> sourceStringForCompare [

	^ String streamContents: [:s | self writeSourceOn: s indent: 0 forCompare: true]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> startInputCommandIn: aTextMorph [

	^ aTextMorph ifNotNil: [SBTextCommand new textMorph: aTextMorph] ifNil: [nil]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> statements [

	^ self isBlockBody ifTrue: [self childSandblocks] ifFalse: [#()]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> stringContents [

	^ self textMorphs detect: [:text | text slot firstNode isTSText] ifFound: [:text |
		#($' $" $`) do: [:char | ((text contents first = char and: [text contents last = char]) and: [(text slot firstNode regex matches: 'a') not]) ifTrue: [^ text contents viewAllButFirstAndLast joinSeparatedBy: '']].
		text contents]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> suggestAlways [

	^ self language suggestAlwaysFor: self
]

{ #category : #'as yet unclassified' }
SBTSBlock >> suggestions [

	^ (self isExpression
		ifTrue: [
			Array streamContents: [:stream |
				SBTSReplacementBlock keywordReplacementsDo: [:pragma | | keyword |
					keyword := pragma arguments fourth.
					(self language language = pragma arguments first and: [keyword sandblockMatch: self contents]) ifTrue: [
						stream nextPut: (SBTSBlockSuggestion new
							command: (SBReplaceMultipleCommand new
									target: self
									replacers: {pragma methodClass buildFor: self language with: Dictionary new})
								in: self sandblockEditor;
							selector: keyword label: 'replacement')]]]]
		ifFalse: [{}]), (self semantics suggestionsFor: self)
]

{ #category : #'action helpers' }
SBTSBlock >> swap2: aNumber [

	self activeTextMorph ifNotNil: [:text |
		(#('(' ')' '[' ']' '{' '}') includes: text contents) ifTrue: [ | options list |
			list := self submorphs asOrderedCollection.
			list addAllFirst: (self owner submorphs first: self submorphIndex - 1).
			list addAllLast: (self owner submorphs allButFirst: self submorphIndex).
			list remove: text.
			list add: text beforeIndex: self submorphIndex + text submorphIndex + aNumber - 1.
			options := SBTSInputParser new
				copyEmbeds: false;
				optionsForTemplate: self owner slot transitionRoot givenBlocks: list.
			self sandblockEditor do: (SBReplaceMultipleCommand new target: self owner replacers: options first).
			text owner sandblockEditor
				startInput: text owner
				at: 1
				replacingContents: false
				in: text.
			^ self]].
	
	^ super swap: aNumber
]

{ #category : #'action helpers' }
SBTSBlock >> swap: aNumber [

	self swapLinearized: aNumber
]

{ #category : #'action helpers' }
SBTSBlock >> swapBlocks: aNumber [

	| leafs index container oldIndex pivot |
	container := self.
	pivot := self activeTextMorph.
	SBToggledCode comment: '' active: 0 do: {
		[(pivot submorphIndex + aNumber = 1 or: [pivot submorphIndex + aNumber = pivot owner submorphCount]) ifTrue: [container := container parentSandblock]]}.
	
	leafs := container submorphs copy.
	index := leafs indexOf: pivot.
	
	[
		oldIndex := index.
		index := index + aNumber.
		leafs swap: oldIndex with: index.
		Transcript showln: leafs.
		(SBTSInputParser new optionsForTemplate: container slot repeater givenBlocks: leafs) ifNotEmpty: [:results | ^ self sandblockEditor do: (SBReplaceMultipleCommand new target: self replacers: results first)]] doWhileTrue: [index + aNumber between: 1 and: leafs size]
]

{ #category : #'action helpers' }
SBTSBlock >> swapLinearized: aNumber [

	| leafs index container oldIndex pivot |
	container := self parentSandblock.
	pivot := self activeTextMorph ifNil: [self].
	(pivot submorphIndex + aNumber = 1 or: [pivot submorphIndex + aNumber = pivot owner submorphCount]) ifTrue: [container := container parentSandblock].
	
	leafs := Array streamContents: [:s | container linearizeOn: s].
	index := leafs indexOf: pivot.
	
	[
		oldIndex := index.
		index := index + aNumber.
		leafs swap: oldIndex with: index.
		Transcript showln: leafs.
		self halt.
		(SBTSInputParser new optionsForTemplate: container slot lastNode givenBlocks: leafs) ifNotEmpty: [:results | ^ self sandblockEditor do: (SBReplaceMultipleCommand new target: self replacers: results first)]] doWhileTrue: [index + aNumber between: 1 and: leafs size]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> template [

	^ self slot firstNode bodyTemplate
]

{ #category : #'as yet unclassified' }
SBTSBlock >> textMorphs [

	^ self submorphs select: [:t | t isTextMorph]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> toplevel [

	^ (self type = self language rootRuleName and: [self owner isNil or: [self owner isTSBlock not]])
		ifTrue: [self]
		ifFalse: [(self ownerThatIsA: SBTSBlock) toplevel]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> tryApplyChange: aBlock input: aString [

	| previousContents insertIndex textMorph |
	textMorph := self activeTextMorph.
	previousContents := textMorph contentsForEdit.
	insertIndex := textMorph contents
		ifNotEmpty: [textMorph cursor]
		ifEmpty: [SBTSInputReconcile endIndex].
	aBlock value: textMorph.
	
	(self prefixValidFor: textMorph in: self submorphs)
		ifTrue: [
			((self factory keywords includes: textMorph contents) and: [(self isMyActiveKeyword: textMorph contents) not]) ifTrue: [
				textMorph contents: previousContents.
				SBTSInputReconcile new for: textMorph input: aString at: insertIndex]]
		ifFalse: [
			textMorph contents: previousContents.
			SBTSInputReconcile new for: textMorph input: aString at: insertIndex]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> tryApplyReplacements: aCollection to: aBlock [

	^ aCollection do: [:pragma | | blockClass |
		blockClass := pragma methodClass.
		
		(pragma method pragmas noneSatisfy: [:p | p keyword = #manual]) ifTrue: [
			(blockClass
				match: aBlock
				against: (SBTSQuery new prepare: pragma arguments second)
				buildSelector: pragma selector) ifNotNil: [:cmd |
				^ self sandblockEditor
					ifNotNil: [:e | e do: (cmd shouldMergeWithNext: true)]
					ifNil: [cmd do]]]]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> type [

	^ self slot type
]

{ #category : #actions }
SBTSBlock >> typeNewLine [
	"workaround, as we want cmd+cr to put a new line, which will otherwise get blocked in keyStroke: because it contains a cmd"
	<inputAction>

	self sandblockEditor cursor cursorPosition textMorph insertString: String cr
]

{ #category : #'as yet unclassified' }
SBTSBlock >> undamagedParentWith: anotherBlock do: aClosure [

	| oldStart newStart |
	oldStart := self.
	newStart := anotherBlock.
	
	[oldStart sourceString = newStart sourceString] whileTrue: [
		oldStart := oldStart parentSandblock.
		newStart := newStart parentSandblock].
	
	oldStart andAllParentSandblocksDo: [:oldParent | newStart andAllParentSandblocksDo: [:newParent | (oldParent type = newParent type and: [oldParent localNestingDepth = newParent localNestingDepth and: [oldParent undamagedParentWithRec: newParent]]) ifTrue: [^ aClosure value: oldParent value: newParent]]]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> undamagedParentWithRec: anotherBlock [

	| oldChild newChild |
	oldChild := self.
	newChild := anotherBlock.
	self parentSandblock with: anotherBlock parentSandblock parentsDo: [:oldParent :newParent |
		oldParent type = newParent type ifFalse: [^ false].
		oldParent childSandblocks size = newParent childSandblocks size ifFalse: [^ false].
		oldParent childSandblocks
			with: newParent childSandblocks
			do: [:old :new | old sourceString = new sourceString ifFalse: [(old ~= oldChild and: [new ~= newChild]) ifTrue: [^ false]]].
		oldChild := oldParent.
		newChild := newParent].
	^ true
]

{ #category : #highlight }
SBTSBlock >> updateAllHighlights [

	^ self slot updateAllHighlightsFor: self
]

{ #category : #'as yet unclassified' }
SBTSBlock >> updateMyHighlight [

	| current |
	self factory hasHighlight ifFalse: [^ self highlight: #_sb_none].
	
	highlight := nil.
	current := self.
	[highlight isNil and: [current notNil and: [current isTSBlock]]] whileTrue: [
		self slot updateHighlightFor: current.
		current := current parentSandblock].
	self clearCacheSelf
]

{ #category : #'as yet unclassified' }
SBTSBlock >> useSuggestion: anItem [

	| editor |
	editor := self sandblockEditor.
	self activeTextMorph contents: ''.
	self tryApplyChange: [:t | t contents: anItem contents] input: anItem contents.
	" we may autocomplete multiple unknowns, where we all always select the last one. typically, in the autocompletion we actually want the first one though "
	editor selection parentSandblock
		allBlocksDetect: [:b | b isUnknown]
		ifFound: [:b | b startInput]
		ifNone: []
]

{ #category : #'as yet unclassified' }
SBTSBlock >> valid [

	^ valid ifNil: [valid := self textMorphs allSatisfy: [:t | t ifNotNil: [t slot firstNode validFor: t effectiveContents in: self submorphs] ifNil: [true]]]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> wantsExtraSpace [

	^ SBToggledCode comment: '' active: 1 do: {[false]. [self slot needsParenthesis: self]}
]

{ #category : #events }
SBTSBlock >> wasDeselected [

	super wasDeselected.
	SBTSListener allSubclassesDo: [:listener | (listener matches: self) ifTrue: [listener wasDeselected: self]].
	self updateMyHighlight
]

{ #category : #events }
SBTSBlock >> wasSelected [

	super wasSelected.
	SBTSListener allSubclassesDo: [:listener | (listener matches: self) ifTrue: [listener wasSelected: self]]
]

{ #category : #actions }
SBTSBlock >> wrapWithToggle [
	<action>

	| target |
	target := self orOwnerSuchThat: #isExpression.
	self sandblockEditor do: (SBReplaceCommand new
		target: target
		replacer: (SBToggle buildFor: self language with: {'wrap' -> self}))
]

{ #category : #actions }
SBTSBlock >> wrapWithWatch [
	<action>

	self isWatch ifTrue: [
		^ self sandblockEditor do: (SBReplaceCommand new
			target: self
			replacer: (self expression adaptSlotFor: self parentSandblock slot))].
	self parentSandblock isWatch ifTrue: [
		^ self sandblockEditor do: (SBReplaceCommand new
			target: self parentSandblock
			replacer: (self parentSandblock expression adaptSlotFor: self parentSandblock slot))].
	
	(self orOwnerSuchThat: [:o | o isTSBlock and: [o isExpression]]) ifNotNil: [:expr |
		self sandblockEditor do: (SBReplaceCommand new
			target: expr
			replacer: (SBWatch2 buildFor: self language with: {'id' -> UUID new asString. 'wrap' -> expr}))]
]

{ #category : #'as yet unclassified' }
SBTSBlock >> writeSourceOn: aStream [

	self writeSourceOn: aStream indent: 0 forCompare: false
]

{ #category : #'as yet unclassified' }
SBTSBlock >> writeSourceOn: aStream indent: aNumber forCompare: aBoolean [

	| parens |
	self children ifEmpty: [^ self].
	
	aStream hasLineInfo ifTrue: [range start line: aStream currentLine character: aStream currentIndexInLine].
	
	parens := self parentSandblock notNil and: [self parentSandblock isTSBlock and: [self slot needsParenthesis: self]].
	(self language indentMatch: self) ifTrue: [self slot indent: 1 on: aStream].
	parens ifTrue: [aStream nextPut: $(].
	self children overlappingPairsDo: [:first :second |
		first writeSourceOn: aStream indent: (self indentFor: first current: aNumber) forCompare: aBoolean.
		aStream nextPutAll: (self slot
			separatorBetween: first
			and: second
			indent: aNumber
			lastCharacterOfFirst: (aStream position > 0 ifFalse: [$ ] ifTrue: [aStream last]))].
	self lastSubmorph
		writeSourceOn: aStream
		indent: (self indentFor: self lastSubmorph current: aNumber)
		forCompare: aBoolean.
	self slot nodes do: [:node | node bodyTemplate andParentsDo: [:type | type hasStatementTerminator ifTrue: [aStream nextPutAll: self language statementTerminator]]].
	parens ifTrue: [aStream nextPut: $)].
	
	aStream hasLineInfo ifTrue: [range end line: aStream currentLine character: aStream currentIndexInLine]
]
